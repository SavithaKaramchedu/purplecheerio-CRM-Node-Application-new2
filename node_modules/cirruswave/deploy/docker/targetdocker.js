const path=require("path");
const fs = require("fs");
const readlineSync = require('readline-sync');

var strDeploy = "";
function Tabs(c)
{
    var strTab = "";
    for(var i=0;i<c;i++)
    {
        strTab += "  ";
    }
    return strTab;
}


const TargetDeployment = require("./target.js");

class TargetDeploymentDocker extends TargetDeployment {
    constructor(destdir, tmpdir, tmpLaunchDir, tmpLaunchDir1, deployconfig)
    {
        super(destdir, tmpdir, tmpLaunchDir, tmpLaunchDir1, deployconfig);
        this.strDefDocker = fs.readFileSync(path.resolve(__dirname, "def.docker"), "utf8");


        this.strComposeDocker = "version: '3'\n";
        this.strComposeKubernetes = "version: '3'\n";
        
        this.strComposeDocker += "networks:\n";
        this.strComposeDocker += Tabs(1)+"isolation-network:\n";
        this.strComposeDocker += Tabs(2)+"driver: overlay\n";
        
        this.strComposeDocker += "services:\n";
        
        
        this.strComposeUbuDocker = this.strComposeDocker;
        
        this.strComposeKubernetes += "services:\n";
        // var strExec = "docker-compose exec";
        this.strSwarmTokens = "";
        this.strMachines = "";
        this.strSwInit = "echo \"leaving swarm\"\n";
        this.strSwInit += "docker swarm leave --force\n";
        this.strSwInit += "docker swarm init";
        this.strSwInit += "\n";
        this.internalip  = null;
        this.swarmmgrMain = false;
        this.username = deployconfig.targets.docker.username;
        this.swarm = true;
        this.kubernetes = false;
    }
    PrepCmdBefore(ts, dpcw)
    {
        // If elb is not present, there has to be one manager.
        if(this.deployconfig.targets.docker){
            if(!this.deployconfig.targets.docker.elb && this.deployconfig.targets.docker.managers.length && this.deployconfig.targets.docker.managers[0])
                this.swarmmgrMain = true;
            if(this.swarmmgrMain && this.deployconfig.targets.docker.managers[0].internalip)
                this.internalip = this.deployconfig.targets.docker.managers[0].internalip;
        }

        var pswd = readlineSync.question('To deploy you need to give dockerhub password. Enter docker hub password. Press enter to quit: ', {
            hideEchoBack: true // The typed text on screen is hidden by `*` (default).
          });
        if(pswd == "")
        {
            console.log("docker deployment requires for you to create a dockerhub account where the images will be stored and are pulled by deployment scripts");
            process.exit(0);
        }
        var strLogin = "docker login -u "+this.username+" -p "+pswd+"\n";
        this.deployconfig.targets[ts].strPrepCmds += strLogin;
        strLogin = "sudo "+strLogin;

        strDeploy += strLogin;
        this.deployconfig.targets[ts].strPrepCmds += "docker-compose -f "+path.resolve(this.destdir, "dd.yml")+" build\n";
        this.deployconfig.targets[ts].strPrepCmds += "docker-compose -f "+path.resolve(this.destdir, "dd.yml")+" push\n";
    }

    PrepCmdAfter(ts)
    {
        if(this.swarm)
        {
            // strDeploy += "sudo docker swarm init\n";
            strDeploy += "sudo docker-compose -f dd.yml pull\n";
            strDeploy += "sudo docker stack deploy";
            if(this.kubernetes)
            {
                strDeploy += " --orchestrator=kubernetes";
                strDeploy += " -c ddKubernetes.yml dd\n"
            }
            else
            {
                strDeploy += " -c dd.yml dd\n";
                // These are ways to get the tokens for joining. Only for documentation. 
                // docker swarm join-token manager
                // docker swarm join-token worker
            }
            /*
            this.deployconfig.targets[ts].strPrepCmds += strDeploy;
            */
    
        }
        else
        {
            //this.deployconfig.targets[ts].strPrepCmds += "docker-compose -f dd.yml up --build"
    
            // this.deployconfig.targets[ts].strPrepCmds += "read -p 'docker-hub username: ' un\n";
            // this.deployconfig.targets[ts].strPrepCmds += "read -s -p 'password: ' pw\n";
            // this.deployconfig.targets[ts].strPrepCmds += "docker login -u $un -p $pw\n";
            // this.deployconfig.targets[ts].strPrepCmds += "read -p 'Continue? ' c\n";
            this.deployconfig.targets[ts].strPrepCmds += "docker-compose -f dd.yml up\n"
        }
        this.deployconfig.targets[ts].strPrepCmds += "docker logout\n"
        strDeploy += "sudo docker logout\n"
    }

    PrepCmdManager(ts, i)
    {
        // console.log("pem="+this.deployconfig.targets.docker.managers[i].pem+" machine="+this.deployconfig.targets.docker.managers[i].machine);
        // deploy only for the first of the managers
        // or if there is an elb, everyone of the managers is independent swarm manager
    
        if(i == 0 || this.deployconfig.targets.docker.elb)
        {
            if(this.deployconfig.targets.docker.elb)
                this.strMachines += "# --Manager"+i+"--\n";
            else
                this.strMachines += "# --Main Manager--\n";
    
            this.strMachines += "scp -i "+this.deployconfig.targets.docker.managers[i].pem+" "+path.resolve(this.destdir, "ubudeploy.sh")+" "+this.deployconfig.targets.docker.managers[i].user+"@"+this.deployconfig.targets.docker.managers[i].machine+":~\n";
            this.strMachines += "scp -i "+this.deployconfig.targets.docker.managers[i].pem+" "+path.resolve(this.destdir, "ubu.yml")+" "+this.deployconfig.targets.docker.managers[i].user+"@"+this.deployconfig.targets.docker.managers[i].machine+":~\n";
            if(!this.deployconfig.targets.docker.managers[i].noubusetup)
            {
                this.strMachines += "scp -i "+this.deployconfig.targets.docker.managers[i].pem+" "+path.resolve(this.destdir, "ubudockersetup.sh")+" "+this.deployconfig.targets.docker.managers[i].user+"@"+this.deployconfig.targets.docker.managers[i].machine+":~\n";
                this.strMachines += "ssh -i "+this.deployconfig.targets.docker.managers[i].pem+" "+this.deployconfig.targets.docker.managers[i].user+"@"+this.deployconfig.targets.docker.managers[i].machine+" bash ubudockersetup.sh\n" ;
            }
            this.strMachines += "# swarm init\n"
            this.strMachines += "ssh -i "+this.deployconfig.targets.docker.managers[i].pem+" "+this.deployconfig.targets.docker.managers[i].user+"@"+this.deployconfig.targets.docker.managers[i].machine+" 'sudo docker swarm init";
            if(!this.deployconfig.targets.docker.elb)
                this.strMachines += " --advertise-addr "+this.internalip+":2377";
            this.strMachines += "'\n" ;
            this.strMachines += "ssh -i "+this.deployconfig.targets.docker.managers[i].pem+" "+this.deployconfig.targets.docker.managers[i].user+"@"+this.deployconfig.targets.docker.managers[i].machine+" bash ubudeploy.sh\n" ;
    
            this.strSwarmTokens += "swrmmgrtoken=$(ssh -i "+this.deployconfig.targets.docker.managers[i].pem+" "+this.deployconfig.targets.docker.managers[i].user+"@"+this.deployconfig.targets.docker.managers[i].machine+" 'sudo docker swarm join-token -q manager')\n" ;
            this.strSwarmTokens += "swrmwrkrtoken=$(ssh -i "+this.deployconfig.targets.docker.managers[i].pem+" "+this.deployconfig.targets.docker.managers[i].user+"@"+this.deployconfig.targets.docker.managers[i].machine+" 'sudo docker swarm join-token -q worker')\n" ;
        }
        else
        {
            this.strMachines += "# --Another Manager--\n";
            if(!this.deployconfig.targets.docker.managers[i].noubusetup)
            {
                this.strMachines += "scp -i "+this.deployconfig.targets.docker.managers[i].pem+" "+path.resolve(this.destdir, "ubudockersetup.sh")+" "+this.deployconfig.targets.docker.managers[i].user+"@"+this.deployconfig.targets.docker.managers[i].machine+":~\n";
                this.strMachines += "ssh -i "+this.deployconfig.targets.docker.managers[i].pem+" "+this.deployconfig.targets.docker.managers[i].user+"@"+this.deployconfig.targets.docker.managers[i].machine+" bash ubudockersetup.sh\n" ;
            }
            // this.strMachines += "# execute ddswjoinmgr.sh\n"
            // this.strMachines += "ssh -i "+this.deployconfig.targets.docker.managers[i].pem+" "+this.deployconfig.targets.docker.managers[i].user+"@"+this.deployconfig.targets.docker.managers[i].machine+" bash ddswjoinmgr.sh\n" ;
    
            this.strSwarmTokens += "ssh -i "+this.deployconfig.targets.docker.managers[i].pem+" "+this.deployconfig.targets.docker.managers[i].user+"@"+this.deployconfig.targets.docker.managers[i].machine+" \"sudo docker swarm join --token $swrmmgrtoken "+ this.internalip+":2377\"\n"
        }    
    }
    PrepCmdWrite(ts)
    {
        fs.writeFileSync(path.resolve(this.destdir, "ubusetupmachines_local.sh"), this.strMachines);
        fs.writeFileSync(path.resolve(this.destdir, "ubu.yml"), this.strComposeUbuDocker);
        
        fs.writeFileSync(path.resolve(this.destdir, "dd.yml"), this.strComposeDocker);
        fs.writeFileSync(path.resolve(this.destdir, "ubu.yml"), this.strComposeUbuDocker);
        if(this.kubernetes)
            fs.writeFileSync(path.resolve(this.destdir, "ddKubernetes.yml"), this.strComposeKubernetes);
        fs.writeFileSync(path.resolve(this.destdir, "ddprep.sh"), this.deployconfig.targets[ts].strPrepCmds);
        fs.writeFileSync(path.resolve(this.destdir, "ddprep.sh"), this.deployconfig.targets[ts].strPrepCmds);
        fs.writeFileSync(path.resolve(this.destdir, "ddswinit.sh"), this.strSwInit);
        if(this.swarmmgrMain)
        {
            fs.writeFileSync(path.resolve(this.destdir, "ubugetswarmtokens_local.sh"), this.strSwarmTokens);
            // TODO: These should write to $swrmmgrtoken and $swrmwrkrtoken
            // deploy for each of the swarm machines should contain the join mgr or worker commands.
        }
        var strUbuDeploy = strDeploy.replace(/dd.yml/g, "ubu.yml");
        strDeploy = strDeploy.replace(/dd.yml/g, path.resolve(this.destdir, "dd.yml"));
        strDeploy = strDeploy.replace(/sudo docker/g, "docker");
        fs.writeFileSync(path.resolve(this.destdir, "dddeploy.sh"), this.strSwInit+strDeploy);
        fs.writeFileSync(path.resolve(this.destdir, "ubudeploy.sh"), strUbuDeploy);
        var strubuds = fs.readFileSync(path.resolve(__dirname, "ubudockersetup.sh"), "utf8");
        fs.writeFileSync(path.resolve(this.destdir, "ubudockersetup.sh"), strubuds);
    }
    PrepCmdWorker(ts, i)
    {
        this.strMachines += "# --Worker--\n";
        console.log("pem="+this.deployconfig.targets.docker.workers[i].pem+" machine="+this.deployconfig.targets.docker.workers[i].machine);
        if(!this.deployconfig.targets.docker.workers[i].noubusetup)
        {
            this.strMachines += "scp -i "+this.deployconfig.targets.docker.workers[i].pem+" "+path.resolve(this.destdir, "ubudockersetup.sh")+" "+this.deployconfig.targets.docker.workers[i].user+"@"+this.deployconfig.targets.docker.workers[i].machine+":~\n";
            this.strMachines += "ssh -i "+this.deployconfig.targets.docker.workers[i].pem+" "+this.deployconfig.targets.docker.workers[i].user+"@"+this.deployconfig.targets.docker.workers[i].machine+" bash ubudockersetup.sh\n" 
        }
        // this.strMachines += "# execute ddswjoinwrkr.sh\n"
        // this.strMachines += "ssh -i "+this.deployconfig.targets.docker.workers[i].pem+" "+this.deployconfig.targets.docker.workers[i].user+"@"+this.deployconfig.targets.docker.workers[i].machine+" bash ddswjoinwrkr.sh\n" ;
        this.strSwarmTokens += "ssh -i "+this.deployconfig.targets.docker.workers[i].pem+" "+this.deployconfig.targets.docker.workers[i].user+"@"+this.deployconfig.targets.docker.workers[i].machine+" \"sudo docker swarm join --token $swrmwrkrtoken "+ this.internalip+":2377\"\n"
    }
    Servicify(ts, appserviceconfig, sysconfig, sysdeploy)
    {
        var sconfig = null;
   
        if(!sysdeploy)
        {
            sconfig = appserviceconfig;
        }
        else
        {
            sconfig = sysconfig;
        }
        for(var s in sconfig.services)
        {
            var strPackage = this.StrPackageDPCWDocker();
            var sc = sconfig.services[s];
            this.ComposeDocker(s, sc);
    
            // COPY deploy.json this enables the service resolution from workflow (see cirruswaveutil.js RestTaskCall) to use servicename instead of localhost to find the container url for the service
            var strDF1 = 'COPY '+this.tmpLaunchDir1+'/deploy.json ./node_modules/cirruswave/lib\n';
            var service = null;

            if(!sysdeploy)
            {
                this.ComposeSysDependencyDocker(sysconfig);
               service = this.deployconfig.appservices[s];
            }
            else
            {
                service = this.deployconfig.systemservices[s];
            }
            strPackage += strDF1;
            // If apps entry is present for this add the entrypoint using the apps[s] entry in this.deployconfig.json
            strPackage += 'WORKDIR /usr/src/app/'+service.workingdir+'\n';
            if(service.fromDir)
                strPackage += 'COPY '+service.fromDir+"/"+service.fromFile+' '+service.toDir+"/"+service.toFile+'\n';

            strPackage += 'ENTRYPOINT '+service.exec+'\n';
            // strPackage += 'ENTRYPOINT tail -f /dev/null\n';
            if(this.swarm)
            {
                this.ComposeSwarmDocker(sysdeploy, s);
            }
    
            fs.writeFileSync(path.resolve(this.tmpdir, s+".docker"), strPackage); 
        }
    }
    ComposeDocker(s, sc)
    {
        this.strComposeDocker += Tabs(2)+s+":\n";
        this.strComposeUbuDocker += Tabs(2)+s+":\n";
        this.strComposeKubernetes += Tabs(2)+s+":\n";
    
        this.strComposeDocker += Tabs(3)+"build:\n";
        // if tmp dir starts relative to the current directory then it needs to be 
        this.strComposeDocker += Tabs(4)+"context: "+this.tmpdir+"\n";
        this.strComposeDocker += Tabs(4)+"dockerfile: "+s+".docker\n"
    
        this.strComposeDocker +=  Tabs(3)+"ports:\n";
        this.strComposeDocker +=  Tabs(4)+"- \""+sc.port+":"+sc.port+"\"\n";
        this.strComposeDocker += Tabs(3)+"image: "+this.username+"/"+s+":latest\n";
    
    
        this.strComposeUbuDocker +=  Tabs(3)+"ports:\n";
        this.strComposeUbuDocker +=  Tabs(4)+"- \""+sc.port+":"+sc.port+"\"\n";
        this.strComposeUbuDocker += Tabs(3)+"image: "+this.username+"/"+s+":latest\n";
    
        this.strComposeKubernetes +=  Tabs(3)+"ports:\n";
        this.strComposeKubernetes +=  Tabs(4)+"- \""+sc.port+":"+sc.port+"\"\n";
        this.strComposeKubernetes += Tabs(3)+"image: "+this.username+"/"+s+":latest\n";
        
        this.strComposeDocker += Tabs(3)+"networks:\n";
        this.strComposeDocker += Tabs(4)+"- isolation-network\n";
    
        this.strComposeUbuDocker += Tabs(3)+"networks:\n";
        this.strComposeUbuDocker += Tabs(4)+"- isolation-network\n";
    
        var ddeploy = {
            dnsservicename: true
        }
    
        var sysfile = path.resolve(this.tmpLaunchDir,"deploy.json");
        fs.writeFileSync(sysfile, JSON.stringify(ddeploy));
    }
    ComposeSysDependencyDocker(sysconfig)
    {
        // Create system services list so that all the appservices can take automatic dependency in the build process
        this.strComposeDocker += Tabs(3)+"depends_on:\n"
        this.strComposeUbuDocker += Tabs(3)+"depends_on:\n"
        for(var sSys in sysconfig.services)
        {
            this.strComposeDocker += Tabs(4)+"- "+sSys+"\n";
            this.strComposeUbuDocker += Tabs(4)+"- "+sSys+"\n";
        }
    }
    ComposeSwarmDocker(fSysDeploy, s){
        var replicas = 1;
        if(!fSysDeploy){
            if(this.deployconfig.appservices[s].replicas)
            {
                replicas = this.deployconfig.appservices[s].replicas;
            }
        }
        else{
            if(this.deployconfig.systemservices && this.deployconfig.systemservices[s] && this.deployconfig.systemservices[s].replicas)
            {
                replicas = this.deployconfig.systemservices[s].replicas;
            }
        }
        this.strComposeDocker += Tabs(3)+"deploy:\n";
        this.strComposeDocker += Tabs(4)+"replicas: "+ replicas+"\n";
        this.strComposeDocker += Tabs(4)+"restart_policy:\n";
        this.strComposeDocker += Tabs(5)+"condition: on-failure"+"\n";
    
        this.strComposeUbuDocker += Tabs(3)+"deploy:\n";
        this.strComposeUbuDocker += Tabs(4)+"replicas: "+ replicas+"\n";
        this.strComposeUbuDocker += Tabs(4)+"restart_policy:\n";
        this.strComposeUbuDocker += Tabs(5)+"condition: on-failure"+"\n";
    
        this.strComposeKubernetes += Tabs(3)+"deploy:\n";
        this.strComposeKubernetes += Tabs(4)+"replicas: "+ replicas+"\n";
        this.strComposeKubernetes += Tabs(4)+"restart_policy:\n";
        this.strComposeKubernetes += Tabs(5)+"condition: on-failure"+"\n";
    
    }
    StrPackageDPCWDocker(){
        var strDF = this.strDefDocker;
        strDF += "COPY "+"docker-pc-wave .\n"
        if(this.deployconfig.npminstallpc)
        {
            // do the proper npm install.
            strDF += 'RUN npm install cirruswave\n';
        }
        if(this.deployconfig.npminstall)
        {
            strDF += 'RUN npm install\n';
        }
        return strDF;
    }
}
module.exports = TargetDeploymentDocker;