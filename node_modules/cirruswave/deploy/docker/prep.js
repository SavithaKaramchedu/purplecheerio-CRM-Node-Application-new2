

const sysserviceconfigfilepath = "../lib/serviceconfig.json";
const path=require("path");
const fs = require("fs");
const program = require('commander');
const tmpLaunchDir1 = "docker-pc-launch"
var deployconfig = null;
var tmpdir = null;

var tmpLaunchDir = null;
var destdir = null;
const TargetDeploymentDocker = require("./targetdocker.js");
const TargetDeploymentAws = require("./targetaws.js");
function AssertFieldExists(f, name, context)
{
    if(!f || f.length < 1)
    {
        console.log("Field="+name+" should have value in "+context);
        return false;    
    }
    if(f === name)
    {
        console.log("field name can not have value "+f+" in "+context);
        return false;
    }
    return true;
}
function PrepCopy(destdir, dpcw){
    var strPrepCopy = "";
    strPrepCopy += "rm -r "+dpcw+"\n";
    strPrepCopy += "mkdir "+dpcw+"\n";
    // Copy the appdir to tmp/docker-pc-wave
    if(deployconfig.appcopy)
    {
        for(i in deployconfig.appcopy)
        {
            strPrepCopy += "mkdir -p "+path.resolve(dpcw, deployconfig.appcopy[i].destdir)+"\n";
            strPrepCopy += 'cp ';
            if(deployconfig.appcopy[i].type == "dir" && deployconfig.appcopy[i].recursive)
                strPrepCopy += '-r ';
            strPrepCopy += path.resolve(deployconfig.appdir, deployconfig.appcopy[i].path)
            if(deployconfig.appcopy[i].type == "dir" && !deployconfig.appcopy[i].recursive)
                strPrepCopy += '/* ';
            strPrepCopy += ' '+path.resolve(dpcw, deployconfig.appcopy[i].destdir)+'/\n';
        }
    }
    if(deployconfig.npminstall)
    {
        // Copy the launchdir contents also tmp/docker-pc-wave
        strPrepCopy += "cp -r "+tmpLaunchDir+'/ '+dpcw+'\n';
    }
    else
    {
        var npmdir = "../../";
        if(deployconfig.npmdir)
            npmdir = deployconfig.npmdir;
        var appdirT = __dirname;
        if(deployconfig.appdir)
            appdirT = deployconfig.appdir;
        strPrepCopy += "cp -LR "+path.resolve(appdirT, npmdir,"node_modules")+" "+dpcw+"/node_modules\n";
        if(deployconfig.pccopy)
            strPrepCopy += 'cp -LR '+path.resolve(appdirT, npmdir)+' '+dpcw+'/node_modules/cirruswave\n';
        // Copy the launchdir contents also tmp/docker-pc-wave
        strPrepCopy += "cp -r "+tmpLaunchDir+'/ '+dpcw+'\n';

        strPrepCopy += "rm -r "+dpcw+"/node_modules/cirruswave/node_modules\n";
    }
    fs.writeFileSync(path.resolve(destdir, "prepcopy.sh"), strPrepCopy);

}
function GenStubs(appserviceconfig, sysconfig, sysdeploy)
{
    var sconfig = null;
   
    if(!sysdeploy)
    {
        sconfig = appserviceconfig;
    }
    else
    {
        sconfig = sysconfig;
    }

    for(var s in sconfig.services)
    {
        var sc = sconfig.services[s];

        if(!sysdeploy)
        {
            if(!deployconfig.appservices)
                deployconfig.appservices = {};
            if(!deployconfig.appservices[s])
                deployconfig.appservices[s] = {};
            if(!deployconfig.appservices[s].workingdir)
                deployconfig.appservices[s].workingdir = ".";



            if(!deployconfig.appservices[s].exec)
            {
                // Generate the app.js
                var strSysApp = 'const app = require("cirruswave");\n'+
                'app.startservice("'+s+'",".","'+deployconfig.appserviceconfig+'");\n';

                var appfile1 = "app_index_"+s+".js";
                var appfile = path.resolve(tmpLaunchDir, appfile1);
                if(!deployconfig.appservices[s].replicas)
                    deployconfig.appservices[s].replicas = 1;
                deployconfig.appservices[s].exec = "node "+appfile1+" > ./app_"+s+".log 2>&1";
                // The following can trigger copy process in the target.servicify call for the generated stub
                deployconfig.appservices[s].fromDir = tmpLaunchDir1;
                deployconfig.appservices[s].fromFile = appfile1;
                deployconfig.appservices[s].toDir = ".";
                deployconfig.appservices[s].toFile = appfile1;
 
                fs.writeFileSync(appfile, strSysApp);
            }
            else
            {
                if(deployconfig.appservices[s].exec.search(">") < 0)
                {
                    // assume there is redirection to log file if > is present in the exec string
                    deployconfig.appservices[s].exec += " > ./app_"+s+".log 2>&1";
                }
            }
        }
        else
        {
            var strSysApp = 'const app = require("cirruswave");\n'+
            'const initoptions={\n'+
            '"aclconfig":"aclconfig.json",\n'+
            '"secret":"'+deployconfig.secret+'",\n'+
            '"appserviceconfig":"./appserviceconfig.json",\n'+
            '"appdir":"./node_modules/cirruswave/examples"';
            if(deployconfig.systemservices && deployconfig.systemservices[s] && deployconfig.systemservices[s].persistence)
            {
                var pers = deployconfig.systemservices[s].persistence;
                if(pers.type !== "file")
                {
                    var fFailed = false;
                    if(!AssertFieldExists(pers.bucketname, "bucketname", "deployconfig.options.persistence when type is s3"))
                        fFailed = true;
                    if(!AssertFieldExists(pers.acckey, "acckey", "deployconfig.options.persistence when type is s3"))
                        fFailed = true;
                    if(!AssertFieldExists(pers.secret, "secret", "deployconfig.options.persistence when type is s3"))
                        fFailed = true;
                    if(!AssertFieldExists(pers.region, "region", "deployconfig.options.persistence when type is s3"))
                        fFailed = true;
                    if(fFailed)
                    {
                        process.exit(1);
                    }
                }
                strSysApp += ",\n";
                strSysApp += '"persistence":'+JSON.stringify(pers, 0, 2);
            }
            strSysApp += '\n};\n'+
            'console.log(JSON.stringify(initoptions, 0, 2));\n'+
            'app.startsystemservice("'+s+'",initoptions);\n';

            var sysfile1 = "sys_index_"+s+".js";
            var sysfile = path.resolve(tmpLaunchDir,sysfile1);
            deployconfig.systemservices[s].exec = "node "+sysfile1+" > ./sys_"+s+".log 2>&1";
            // The following can trigger copy process in the target.servicify call for the generated stub
            deployconfig.systemservices[s].workingdir = ".";
            deployconfig.systemservices[s].fromDir = tmpLaunchDir1;
            deployconfig.systemservices[s].fromFile = sysfile1;
            deployconfig.systemservices[s].toDir = ".";
            deployconfig.systemservices[s].toFile = sysfile1;
            fs.writeFileSync(sysfile, strSysApp);
        }
    }
}


function main()
{
 	//initialize();
 	program
		.version('1.0')
		.option('-h, --help', 'usage info')
		.option('-f, --deployconfigpath <filepath>', 'full path including filename for the deployconfig')
		//.option('-u, --username <username>', 'username for dockerhub (this is required)')
		//.option('-d, --destdir <dir>', 'destination directory path for the deployment scripts ddprep.sh and ddrestart.sh to be stored')
		//.option('-c, --cleanup', 'delete contents and the directory deployconfig.tmpdir')
		//.option('-k, --kubernetes', 'Launch in kubernetes')
		//.option('-s, --swarm', 'swarm (stack) mode where multiple replicas can be deployed whitch atuo restart on failure')
		.parse(process.argv)
        .on('--help', function(){
            console.log(' ');
            //console.log('node prep.js -u phanipc -f ./deployconfig.json -d ./tmp -c -s');
            console.log('node prep.js -f ./deployconfig.json');
          });
    
	if (!process.argv.slice(2).length || !program.deployconfigpath) {
        program.outputHelp();
        process.exit(0);
    }
    deployconfig = require(path.resolve(__dirname, program.deployconfigpath));

    // kubernetes means it's automatically a swarm.
    program.cleanup = true;
    program.swarm = true;
    if(program.kubernetes)
        program.swarm = true;
    if(!program.deployconfigpath)
    {
        deployconfig = require(path.resolve(__dirname, "./deployconfig.json"));
    }
    else
    {
        deployconfig = require(path.resolve(__dirname, program.deployconfigpath));
    }
    if(deployconfig.appdir)
    {
        tmpdir = path.resolve(deployconfig.appdir, deployconfig.tmpdir);
        tmpLaunchDir = path.resolve(tmpdir, tmpLaunchDir1);
        destdir = path.resolve(deployconfig.appdir, deployconfig.destdir);
    }
    else
    {
        tmpdir = path.resolve(__dirname, deployconfig.tmpdir);
        tmpLaunchDir = path.resolve(tmpdir, tmpLaunchDir1);
        destdir = path.resolve(__dirname, deployconfig.destdir);
    }
    // console.log("tmpdir="+tmpdir);
    // console.log("tmpLaunchDir="+tmpLaunchDir);
    // console.log("destdir="+destdir);
    // process.exit(0);
        
    if(tmpdir === destdir)
    {
        console.log("!!!!!!!!Error!!!!!!!!\n\nin deployconfig.json the tmpdir and destdir can not be the same.\n\n!!!!!!!!Error!!!!!!!!");
        program.outputHelp();
        process.exit(0);
    }
    /*
    if(program.destdir)
        destdir = path.resolve(__dirname, program.destdir);
    else
        destdir = path.resolve(__dirname, "tmp");
    console.log(__dirname);
    console.log(tmpLaunchDir);
    console.log(destdir);
    console.log(program.deployconfigpath);
    console.log(path.resolve(__dirname, "./deployconfig.json"));
    console.log(path.resolve(__dirname, program.deployconfigpath));
    console.log(tmpdir);
    process.exit(0);
    */
    fs.existsSync(destdir) || fs.mkdirSync(destdir);
    if(fs.existsSync(tmpdir))
    {
//        console.log(tmpdir);
        if(!program.cleanup)
        {
            console.error("temporary directory designated in deployconfig '"+tmpdir+"' exists and may not be empty. Please empty and delete this directory or change set the deployconfig.tmpdir to another directory");
            return;
        }
        var cp = require('child_process');
        if(fs.existsSync(path.resolve(tmpdir, "docker-pc-launch")))
        {
            cp.execSync("rm -r "+path.resolve(tmpdir, "docker-pc-launch"));
        }
        if(fs.existsSync(path.resolve(tmpdir,"keymgr.docker")))
        {
            cp.execSync("rm -r "+path.resolve(tmpdir,"*.docker"));
        }
    }
    else
        fs.mkdirSync(tmpdir);

    fs.existsSync(tmpLaunchDir) || fs.mkdirSync(tmpLaunchDir,{recursive:true});
    deployconfig.targets.docker.targetdeployment = new TargetDeploymentDocker(destdir, tmpdir, tmpLaunchDir, tmpLaunchDir1, deployconfig, sysserviceconfigfilepath);
    deployconfig.targets.aws.targetdeployment = new TargetDeploymentAws(destdir, tmpdir, tmpLaunchDir, tmpLaunchDir1, deployconfig, sysserviceconfigfilepath);
   
    
    // The bash script for preparing the docker-pc-wave from current app directory.
    var dpcw = path.resolve(tmpdir,"docker-pc-wave");
    PrepCopy(destdir, dpcw);

    var appserviceconfig = require(path.resolve(deployconfig.appdir, deployconfig.appserviceconfig));
    var sysconfig = require(sysserviceconfigfilepath);
    GenStubs(appserviceconfig, sysconfig, false);
    GenStubs(appserviceconfig, sysconfig, true);
    var appdirT = destdir;
    if(deployconfig.appdir)
        appdirT = deployconfig.appdir;

    for(var ts in deployconfig.targets)
    {
        deployconfig.targets[ts].targetdeployment.Servicify(ts, appserviceconfig, sysconfig, false);
        deployconfig.targets[ts].targetdeployment.Servicify(ts, appserviceconfig, sysconfig, true);
        deployconfig.targets[ts].strPrepCmds = "bash "+path.resolve(destdir, "prepcopy.sh")+"\n";

        deployconfig.targets[ts].targetdeployment.PrepCmdBefore(ts, dpcw);
        for(var i in deployconfig.targets[ts].managers)
        {
            if(!deployconfig.targets[ts].managers[i].active)
                continue;
            deployconfig.targets[ts].managers[i].pem = path.resolve(appdirT, deployconfig.targets[ts].managers[i].pem);
            console.log("Target="+ts+" Manager machine="+deployconfig.targets[ts].managers[i].machine);

            deployconfig.targets[ts].targetdeployment.PrepCmdManager(ts, i);
        }
        if(deployconfig.targets[ts].targetdeployment.PrepCmdWorker){
            if(!deployconfig.targets[ts].elb){
                // workers are only relevant if elb is not present.
                // presence of elb means, each machine is separate manager of it's own warm.
                for(var i in deployconfig.targets[ts].workers)
                {
                    if(!deployconfig.targets[ts].workers[i].active)
                        continue;
                        deployconfig.target[ts].workers[i].pem = path.resolve(appdirT, deployconfig.target[ts].workers[i].pem);
                        console.log("Target="+ts+" Worker machine="+deployconfig.targets[ts].workers[i].machine);
                        deployconfig.targets[ts].targetdeployment.PrepCmdWorker(ts, i);
                }
            }
        }       
  deployconfig.targets[ts].targetdeployment.PrepCmdAfter(ts);
        deployconfig.targets[ts].targetdeployment.PrepCmdWrite(ts);
    }

}
 main();